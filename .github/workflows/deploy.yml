name: Build & Deploy (ACR + VMSS with RAW compose, pinned tag)

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  ACR_NAME: group4acr
  ACR_LOGIN_SERVER: group4acr.azurecr.io
  RG: RG-group4
  VMSS_BE: vmss-backend-group4
  VMSS_FE: vmss-frontend-group4
  APP_DIR: /home/azureuser/ecommerce-app-three-tier-azure-db-ih
  # <-- عدّل هذا فقط إذا ملفك ليس في الجذر
  COMPOSE_PATH_IN_REPO: docker-compose.yml
  BE_HEALTH_URL: http://127.0.0.1:3001/health
  FE_HEALTH_URL: http://127.0.0.1:3000/health

jobs:
  build:
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    outputs:
      RAW_URL: ${{ steps.compose.outputs.RAW_URL }}
      TAG: ${{ steps.tag.outputs.TAG }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ACR login
        run: az acr login --name "$ACR_NAME" --only-show-errors

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set TAG
        id: tag
        run: echo "TAG=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Build & Push BACKEND
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.tag.outputs.TAG }}"
          docker build -t "$ACR_LOGIN_SERVER/ecommerce-backend:${TAG}" \
                       -t "$ACR_LOGIN_SERVER/ecommerce-backend:latest" ./ecommerce-app-backend
          docker push "$ACR_LOGIN_SERVER/ecommerce-backend:${TAG}"
          docker push "$ACR_LOGIN_SERVER/ecommerce-backend:latest"

      - name: Build & Push FRONTEND
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.tag.outputs.TAG }}"
          docker build --build-arg COMMIT_SHA="${TAG}" \
                       -t "$ACR_LOGIN_SERVER/ecommerce-frontend:${TAG}" \
                       -t "$ACR_LOGIN_SERVER/ecommerce-frontend:latest" ./ecommerce-app-frontend
          docker push "$ACR_LOGIN_SERVER/ecommerce-frontend:${TAG}"
          docker push "$ACR_LOGIN_SERVER/ecommerce-frontend:latest"

      - name: Prepare RAW compose URL
        id: compose
        shell: bash
        run: |
          set -euo pipefail
          RAW="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/${COMPOSE_PATH_IN_REPO}"
          echo "RAW_URL=$RAW" | tee -a "$GITHUB_OUTPUT"
          echo "Using compose: $RAW"
          # تأكيد أنه موجود (200 OK)
          curl -fsI "$RAW" >/dev/null || { echo "❌ Compose not found at $RAW"; exit 1; }

  deploy-backend:
    runs-on: ubuntu-latest
    needs: build
    permissions: { id-token: write, contents: read }
    steps:
      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Roll BACKEND on each VM (pin exact tag)
        shell: bash
        env:
          RAW_URL: ${{ needs.build.outputs.RAW_URL }}
          TAG: ${{ needs.build.outputs.TAG }}
        run: |
          set -euo pipefail
          mapfile -t NAMES < <(az vmss list-instances -g "$RG" -n "$VMSS_BE" --query "[].name" -o tsv)
          [ ${#NAMES[@]} -gt 0 ] || { echo "No instances in $VMSS_BE"; exit 0; }

          read -r -d '' REMOTE <<'EOS'
          set -euxo pipefail
          APP_DIR="__APP_DIR__"
          ACR_NAME="__ACR_NAME__"
          ACR_LOGIN_SERVER="__ACR_LOGIN_SERVER__"
          RAW_URL="__RAW_URL__"
          IMAGE_TAG="__TAG__"
          HEALTH_URL="__HEALTH_URL__"

          # ensure docker compose exists
          if ! docker compose version >/dev/null 2>&1; then
            if ! command -v docker-compose >/dev/null 2>&1; then
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/2.29.7/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose || true
            fi
          fi

          mkdir -p "$APP_DIR" && cd "$APP_DIR"
          curl -fsSL "$RAW_URL" -o docker-compose.yml
          printf "%s\n" "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" "IMAGE_TAG=$IMAGE_TAG" > .env

          az login --identity
          TOKEN=$(az acr login -n "$ACR_NAME" --expose-token --query accessToken -o tsv)
          echo "$TOKEN" | docker login "$ACR_LOGIN_SERVER" -u 00000000-0000-0000-0000-000000000000 --password-stdin

          # pull + hard recreate service
          docker compose --env-file .env pull backend || docker-compose --env-file .env pull backend
          docker rm -f ecommerce-backend 2>/dev/null || true
          docker compose --env-file .env up -d --no-deps --force-recreate backend || docker-compose --env-file .env up -d --no-deps --force-recreate backend

          # wait health
          for i in $(seq 1 36); do
            curl -fsS "$HEALTH_URL" >/dev/null && { echo "Backend healthy"; exit 0; }
            sleep 5
          done
          echo "Backend failed healthcheck"; docker ps --filter name=ecommerce-backend
          docker logs $(docker ps --filter name=ecommerce-backend -q) --tail 200 || true
          exit 1
          EOS

          REMOTE=${REMOTE//__APP_DIR__/$APP_DIR}
          REMOTE=${REMOTE//__ACR_NAME__/$ACR_NAME}
          REMOTE=${REMOTE//__ACR_LOGIN_SERVER__/$ACR_LOGIN_SERVER}
          REMOTE=${REMOTE//__RAW_URL__/$RAW_URL}
          REMOTE=${REMOTE//__TAG__/$TAG}
          REMOTE=${REMOTE//__HEALTH_URL__/$BE_HEALTH_URL}
          B64=$(printf '%s' "$REMOTE" | base64 -w0)

          for VM in "${NAMES[@]}"; do
            echo ">>> BACKEND on $VM"
            az vm run-command invoke -g "$RG" -n "$VM" --command-id RunShellScript \
              --scripts "bash -lc 'echo $B64 | base64 -d > /tmp/run.sh && bash /tmp/run.sh'"
          done

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: [build, deploy-backend]   # نضمن ترتيب التنفيذ + إتاحة needs.build.outputs
    permissions: { id-token: write, contents: read }
    steps:
      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Roll FRONTEND on each VM (pin exact tag + verify)
        shell: bash
        env:
          RAW_URL: ${{ needs.build.outputs.RAW_URL }}
          TAG: ${{ needs.build.outputs.TAG }}
        run: |
          set -euo pipefail
          mapfile -t NAMES < <(az vmss list-instances -g "$RG" -n "$VMSS_FE" --query "[].name" -o tsv)
          [ ${#NAMES[@]} -gt 0 ] || { echo "No instances in $VMSS_FE"; exit 0; }

          read -r -d '' REMOTE <<'EOS'
          set -euxo pipefail
          APP_DIR="__APP_DIR__"
          ACR_NAME="__ACR_NAME__"
          ACR_LOGIN_SERVER="__ACR_LOGIN_SERVER__"
          RAW_URL="__RAW_URL__"
          IMAGE_TAG="__TAG__"
          HEALTH_URL="__HEALTH_URL__"

          if ! docker compose version >/dev/null 2>&1; then
            if ! command -v docker-compose >/dev/null 2>&1; then
              sudo curl -fsSL "https://github.com/docker/compose/releases/download/2.29.7/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose || true
            fi
          fi

          mkdir -p "$APP_DIR" && cd "$APP_DIR"
          curl -fsSL "$RAW_URL" -o docker-compose.yml
          printf "%s\n" "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" "IMAGE_TAG=$IMAGE_TAG" > .env

          az login --identity
          TOKEN=$(az acr login -n "$ACR_NAME" --expose-token --query accessToken -o tsv)
          echo "$TOKEN" | docker login "$ACR_LOGIN_SERVER" -u 00000000-0000-0000-0000-000000000000 --password-stdin

          docker compose --env-file .env pull frontend || docker-compose --env-file .env pull frontend
          docker rm -f ecommerce-frontend 2>/dev/null || true
          docker compose --env-file .env up -d --no-deps --force-recreate frontend || docker-compose --env-file .env up -d --no-deps --force-recreate frontend

          # wait and print proof
          for i in $(seq 1 36); do
            if curl -fsS "$HEALTH_URL" >/dev/null; then
              echo -n "version: "; cat /usr/share/nginx/html/version.txt || echo no-version
              echo "--- css files ---"; ls -l /usr/share/nginx/html/static/css || true
              echo "--- js files ---";  ls -l /usr/share/nginx/html/static/js  || true
              exit 0
            fi
            sleep 5
          done
          echo "Frontend failed healthcheck"
          docker ps --filter name=ecommerce-frontend
          docker logs $(docker ps --filter name=ecommerce-frontend -q) --tail 200 || true
          exit 1
          EOS

          REMOTE=${REMOTE//__APP_DIR__/$APP_DIR}
          REMOTE=${REMOTE//__ACR_NAME__/$ACR_NAME}
          REMOTE=${REMOTE//__ACR_LOGIN_SERVER__/$ACR_LOGIN_SERVER}
          REMOTE=${REMOTE//__RAW_URL__/$RAW_URL}
          REMOTE=${REMOTE//__TAG__/$TAG}
          REMOTE=${REMOTE//__HEALTH_URL__/$FE_HEALTH_URL}
          B64=$(printf '%s' "$REMOTE" | base64 -w0)

          VERS=()
          for VM in "${NAMES[@]}"; do
            echo ">>> FRONTEND on $VM"
            OUT=$(az vm run-command invoke -g "$RG" -n "$VM" --command-id RunShellScript \
              --query "value[0].message" -o tsv \
              --scripts "bash -lc 'echo $B64 | base64 -d > /tmp/run.sh && bash /tmp/run.sh'")
            echo "$OUT"
            V=$(echo "$OUT" | sed -n 's/^version: *//p' | head -n1)
            VERS+=("$V")
          done

          # لو لُوحظ اختلاف نسخة بين الـ VMs نفشل—هذا يمنع تذبذب النسخ
          if [ "$(printf '%s\n' "${VERS[@]}" | sort -u | wc -l)" -ne 1 ]; then
            echo "Detected mixed frontend versions across VMs: ${VERS[*]}"
            exit 1
          fi
